JAVA
-----
    - java is a programming language and a platform independent(Os) , jvm dependent
    - it is a high level programming language
    - java is WORA(write once run anywhere) programming language

history:
-------
    - java was developed in the year of 1991 by james gosling with his green team 
    - java is introduced in the year of 1995 by sun microsystems
    - In 1995 java first version was released
     versions released:
     -----------------
         java 1.0- 1996
         java 1.1- 1997
         java 1.2- 1998
         java 1.8- 2014
         java 23- 2024
         java 24- 2025-march-18
         java 25- 2025-september-16
https://en.wikipedia.org/wiki/Java_version_history




jdk-java development kit
   - it consists of jre  and development tools 
    like javac and java etc.,
jre-java runtime environment
    -jre consist of jdk and library to develop and run 
     java application
jvm-java virtual machine
   -jvm helps java to run on different platforms


features:
---------
1.platform independent: java can be executed on any platform
     (any os like windows,linux,mac)
        - java files must save with .java extension
        - java files are high level programming language
                compiles
     ____.java--------------->____.class (bytecode)
       - .java files compiles into .class files by java compiler
          cmd: javac filename.java
       - to execute java file (jvm /interpreter)
        cmd: java filename

             javac filename.java               java className
___.java  <----------------------> ____.class<-----------------> output



Note : java is a platform independent but jdk dependent
     : to compile the code main method is not required bcoz,
       compiler will check syntax .
     : to execute the code main method is required bcoz ,
       interpreter/jvm will search for main method as entry point

2.strongly typed: java is a strongly typed language
3.object oriented: java is a object oriented language
                 : polymorphism,inheritance,encapsulation,abstraction
4.dynamic: java is a dynamic language
5.robust and portable:
                    - java is a robust and portable language
                    - it consist garbage collection and memory management
                    - it does't have pointers like c++
6.secure: java is a secure language
        : it provides security features like access modifiers
7.java is a case sensitive language 
        


syntax of java program:
----------------------

//package - folder
package basic_project;
/*
 * public - access modifier
 * class- keyword
 * FirstProgram-Identifier
 * */
public class FirstProgram {
	/*
	 * main()-entry point to run the program
	 * public - access modifier
	 * static- non access modifier
	 * void -return type
	 * main- identifier
	 * String - Data type
	 * args- identifier
	 * */
	public static void main(String[] args) {
		System.out.println("hlo world");
	}

}




tokens: building blocks of java program
=======
    1.keywords : reserved words/predefined words
               eg:public ,static,void etc.,




    2.Identifiers: names given to variables,methods,classes,
                   interface etc.,
        
        Rules: 
    1.cannot start with digit and space and special characters
    2.cannot contain space and special characters other than(_ and $)
    2.keywords cannot be used as identifiers
    3.identifiers are case sensitive
    4.identifiers are unique

Conventions:
    1.class and interface names should start with capital letter(CamelCase)
     eg:FirstProgram
    2.method and variables should start with small letter(PascalCase)
     eg:firstProgram


    3.literals: values /data /constant 
    4.Operators
    5.separators : delimiters
                  eg: ;, ., :, /, etc.,


------------------------------------------------------------------------------------------

Variables:(identifier/reference variable)
==========
     - it is a container to store values / data / literal
     - it is a reference data type


Variable declaration : 
----------------------
    datatype identifier;

Note: local variable must be initialized before use

Variable initialization:(variable assignment)
-------------------------
    datatype identifier=value;
variable re-initialization:
----------------------------
    datatype identifier=value;
             identifier=value2;

variable re-declaration:
-------------------------
    datatype identifier=value;
    datatype identifier=value2;

Note : variable re-declaration is not allowed  in java


Variables types:
==================
          1.Based on Scope
                 1.Local variable
                 2.Global variable(static variable+ instance/non static variable)
          2.Based on data type
                 1.Primitive variables
                         - a variable can store single value/primitive data  
                 2.Non primitive variables
                         - a variable can store multiple values/address of variables/non primitive data 
          3.Based on access modifiers(applicable to global variables only for visibility)
                 1.Public variable
                 2.Private variable
                 3.Protected variable
                 4.Default variable


Note : final variables cannot be changed
      Constants: Constants means fixed values


Data Types:
==========
     - it defines which type of values can be stored in a variable

Primitive data types: it store single value
=====================
    1.Numbers 
            1.Integers 
                       1.byte   -128 to 127      
                       2.short  -32768 to 32767  
                       3.int    -2147483648 to 2147483647
                       4.long   -9223372036854775808 to 9223372036854775807
            2.Decimal 
                       5.float  -3.4028235E38 to 3.4028235E38
                       6.double -1.7976931348623157E308 to 1.7976931348623157E308

    2.Characters       7.char    single character(white space)  
    3.Boolean          8.boolean  true or false

Note : boolean doesn't have any min and max value
       

Non primitive data types: it stores multiple values/address of variables
=========================
    1.String
    2.Array
    3.Object
    4.Class/interface/enum
    


Scanner class:
--------------
    - it is used to take input from user
    - it is a class from java.util package

    syntax:
        import java.util.Scanner; 
        Scanner sc=new Scanner(System.in);
        
        byte b=sc.nextByte();
        short s=sc.nextShort();
        int i=sc.nextInt();
        long l=sc.nextLong();
        float f=sc.nextFloat();
        double d=sc.nextDouble();
        char c=sc.next().charAt(0); //for single character
        boolean b=sc.nextBoolean();
        String s=sc.nextLine(); // for sentence
        

Note : InputMismatchException is thrown by scanner class when user enter wrong data type

import statements:
==================
    - it is used to import a package
    - it is a statement
    - it is used to import a class/interface present in different package
    - for java.lang package we don't need to use import statement, by default 
     java.lang package is imported by compiler
   

printing statements:
====================
    - it is used to print a value on console
    - it is a statement
    - it is used to print a value on console

syntax:
    System.out.println(value); - with new line
    System.out.print(value); - without new line
    System.out.printf(format,value); - with format
    System.err.println(value); - with new line for error message


Note :
------
   - System is a class from java.lang package
   -  . is used to access members of class

    System.err: standard error stream
    System.in: standard input stream
    System.out: standard output stream


TypeCasting/Type Conversion:
-----------------------------
   - the process of converting one data type to another data type
   Types:
       1.primitive type casting
       2.non primitive type casting

1.Primitive type casting:
-------------------------
   - it is used to convert one primitive data type to another primitive data type
   Types:
      1.implicit type casting/auto type casting/widening
              - converting smaller data type to larger data type
              - no loss of data
              - compiler implicit add cast operator
      2.explicit type casting/forced type casting/narrowing
              - converting larger data type to smaller data type
              - loss of data
              - programmer explicitly add cast operator

order:
    byte ----> short ----> 
                           int ----> long ----> float ----> double
                char ---->

 size            byte     bits
-------------------------------------
   byte           1         8
   short          2         16
   int            4         32
   long           8         64
   float          4         32
   double         8         64
   char           2         16
   boolean        1         8

Note : can't convert boolean to any other data type and vice versa


Non primitive type casting:
----------------------------
   - the process of converting one non primitive data type to 
     another non primitive data type
       types:
            1.implicit type casting/UpCasting/auto type casting
                 The process of converting(storing) child class object  
                 to parent class object
                 syntax: 
                    Parent refName=new ChildClass();
            2.explicit type casting/DownCasting/forced type casting
                  The process of converting(storing) parent class object 
                  to child class object
                  syntax: 
                    ChildClass refName=(ChildClass) new ParentClass();
                - UpCasting is mandatory for DownCasting, without UpCasting
                  if we perform DownCasting it will throw ClassCastException

Note : instanceof operator is used to check the type of object
       it avoids ClassCastException
       syntax:
            if(parentRefName instanceof ChildClass){
              ChildClass refName=(ChildClass)parentRefName;
            }
       






==============================================================================
==============================================================================

Operators:
+++++++++
       1.Arithmetic operators : + , - , * , / , %
       2.Relational/comparison operators: == , != , > , < , >= , <=
       3.Logical operators : && , || , !
       4.Bitwise operators : & , | , ~ , ^ , << , >>
       5.Assignment operators : = , += , -= , *= , /= , %=
       6.Unary operators:
                   1.increment operator
                                 1.pre-increment operator: ++a
                                 2.post-increment operator : a++
                   2.decrement operator
                                 1.pre-decrement operator: --a
                                 2.post-decrement operator : a--
       7.Ternary/conditional operators
               operand1?operand2:operand3
               condition?true:false

precedence/priority of operators:
=================================
    ()
    ! , ~
    * , / , %
    + , -
    << , >>
    & , |
    == , != , > , < , >= , <=
    &&
    ||
    = , += , -= , *= , /= , %=
    

Statements:
============
       1.printing statements
       2.conditional statements
       3.looping statements
       
2.Conditional statements:
-------------------------
       1.if statement
       2.else if statement
       3.else if ladder statement
       4.nested if statement
       5.switch statement

Note :
-------
 switch :
   - it can accept a value/data/expression/variable
   - it will accept byte , short , int , char , String , enum (constant)
   - it won't accept duplicate cases
   - default is optional
   - break is optional, but used to terminate a case

3.looping statements:
---------------------
       1.while loop
       2.do while loop
       3.for loop
       4.for each loop(advanced for loop/enhanced for loop)
       5.nested loop
-----------------------------------------------------------------
                        while                           do while
----------------------------------------------------------------
no of min iterations     0                         1
                    checks the condition         firstly it executes the block 
                    then executes the block      then checks the condition
-----------------------------------------------------------------


====================================================================================================================================
Methods:
--------
     - It is a block of code which is used to perform a specific task,
       which consist collection of statements
     - It is a re-usable block of code(call method n times)
     - without invoking a method it won't execute the method
     - can't create a method inside a method

     syntax:
      
      accessModifier modifier return_type method_name(parameters){
          ----
          ---
          return ;
      }
method signature:
-----------------
         methodName (parameters)
             
method definition/declaration:
----------------------------
         accessModifier modifier return_type method_name(parameters)

method body:
------------
         {
             ----
             ----
             return type;
         }
       
Return type:
-----------
     - it is a data type which is used to return a value from a method
       to a caller

Note : return type of main method must be void
     : if return type is void , then return statement is optional
     : if return type is other than void , then return statement is mandatory

Parameters/arguments:
---------------------
       - it is a variable which is used to pass a value to a method
       - it is a local variable to a method
       Based on parameters:
       -------------------
                     1.Argumented method/parameterized method
                     2.Non-argumented method/non-parameterized method
        actual parameters:
        ------------------
                     1. it is a value/data passed to a method
                     m1(a);
        formal parameters:
        ------------------
                     2. it is a variable which is used to collect and store a value passed to a method
                      m1(int a)
Method Overloading:
-------------------
    - The process of having multiple methods with same name but different parameters or
      formal arguments in same class is called method overloading
Rules:
------
    1. method name must be same
    2. number of parameters must be different
    3. data type of parameters must be different
    4. order/position/sequence of parameters must be different


Class:
------
    - it is a blueprint/template to create objects
    - it is a non primitive data and reference data type
    - it is a container to store values/data/literals
    - it is a collection of variables/properties/data members and methods/functions


Object:
-------
    - it is a real world entity
    - it is a instance of a class
    - it is a reference data type
    - Constructor is used to create an object



constructor:
------------
     - it is a special method which is used to create objects
     - it is a block of code which is executed when object is created
     - it is used to initialize data members of objects
Note:
------- 
    - constructor name should be same as class name
    - constructor does not return any value

Types:
------
     1. default constructor:
         - by default compiler creates default constructor
         - once user creates a constructor it will override(remove) 
           default constructor
     2. user defined constructor
          1. parameterized constructor/argumented constructor
          2. non parameterized constructor/no argumented constructor
        
Constructor overloading:
-------------------------
      - the process of creating multiple constructors with different 
        parameters in same class is called constructor overloading
rules:
      1.no of args should be different
      2.data types of args should be different
      3.order of args should be different  


-------------------------------------------------------------------------
                      method                            constructor
-------------------------------------------------------------------------
return type           yes                                  no
modifiers            yes                                   no
name                  can be anyName                 same as className
use                  performs a task                 creates an object
                                              initializes data members
-------------------------------------------------------------------------

Modifiers:(specifiers)
==========
    - it is a keyword which is used to modify ,access of methods and 
      variables
    - it is used to modify access of methods and variables
    Types:
        1.Access modifiers:(visibility)
                      1.public
                      2.private
                      3.protected
                      4.default
        2.Non access modifiers(modifiers):
                      1.static
                      2.final
                      3.abstract
                      4.synchronized etc.,


----------------------------------------------------------------------------
                       private     default    protected    public
---------------------------------------------------------------------------
with in class          yes         yes         yes          yes

with in package        no          yes         yes           yes

with in another
package but subclass   no         no          yes           yes


with in another        no        no           no            yes
package
----------------------------------------------------------------------------

Note:
----
   - class can't be private and protected 


Class members:
==============
    1.static members
    2.instance/non static members

static:
-------
      - it is a keywords used to modify methods and variables
      - static members will belongs to class and not to objects

loading of members:
-------------------
      - static members will be loaded into static area when
        class is loaded
      - it executes static initializers before main()
    
      - non static members will be loaded into heap area when
       object is created
      -it executes non static initializers before constructor
       calls

static initializers:
-------------------
      - it is a block of code which is executed when class is loaded
      - it is used to initialize static members of class
      syntax:
          static{
          
          }

non static initializers:
------------------------
      - it is a block of code which is executed when object is created
      - it is used to initialize non static members of class
    syntax:
          {
          
          }






Accessibility:
-------------
   1.In same class
         in static method:
               - static members can access directly/className
               - non static members can access by using object reference
         in non static method:
              - static and non static members directly

   2.In Different class:
       - static members can access by using class name
       - non static members can access by using object
         

==========================================================================================


Arrays:
=======
    - it is used to store multiple values in a single variable of same/homogenous data type
    - it is a non primitive data type/reference data type
    - it is fixed in size(immutable for size)
    - it is indexed and indexed start from 0
    - mutable for elements

note : values of an array can be modified but size of an array 
      can't be modified
creation of array:
-----------------
    datatype [] name=new datatype[size];
    datatype [] name=new datatype[]{value1,value2,value3};
    datatype name[]={value1,value2,value3};
    datatype [] name=new datatype[size]{value1,value2,value3};
accessing elements of array:
----------------------------
    name[index]; // for reading
    name[index]=value; // for writing/modifying
length of array:
----------------
    name.length; // for reading

Arrays methods:
===============
   - Arrays is a class from java.util package
   - it consist static methods which are used to perform 
     operations on arrays 

toString():
------------    
    - it is used to convert array to string
    - it helps to print array elements rather than address
    syntax:
        Arrays.toString(arrName);

sort():
-------
    - it is used to sort array elements
    - it helps to sort array elements in ascending order
    syntax:
        Arrays.sort(arrName);
    - to sort in descending order
        Arrays.sort(arrName,Collections.reverseOrder());

binarySearch():
----------------
    - it is used to search for an element in array
    - it helps to search for an element in array in ascending order
    syntax:
        int index=Arrays.binarySearch(sortedArray,element);
    - if element found it returns the index of that element
    - if element not found it returns  -(index+1)
    - to search in descending order
        int index=Arrays.binarySearch(sortedArray,element,
        Collections.reverseOrder());
equals():
---------
    - it is used to compare two arrays
    syntax:
        boolean result=Arrays.equals(arr1,arr2);
    - it returns true if both arrays are equal
    - it returns false if both arrays are not equal
mismatch():
------------
    - it is used to find the index of first mismatched elements
    syntax:
       int index=Arrays.mismatch(arr1,arr2);
    - it returns the index of first mismatched elements
    - it returns -1 if both arrays are equal

copyOf():
---------
    - it is used to copy one array to another array
    syntax:
        datatype [] newName=Arrays.copyOf(arrName,size);
Note : size can be greater or equal or less to arrName.length
     : it will copy from 0th index to endIndex-1th index
copyOfRange():
--------------
    - it is used to copy one array to another array
    syntax:
        datatype [] newName=Arrays.copyOfRange
          (arrName,startIndex,endIndex);
Note : it will copy from startIndex to endIndex-1th index

multidimensional arrays:
-------------------------
    - it is used to store multiple arrays in a single variable
    syntax:

      datatype [] [] name=new datatype[rowSize][columnSize];

      datatype[][]name={
          {value1,value2,value3},
          {value1,value2,value3},
          {value1,value2,value3}
      };

note : if rows and columns are equal then it is called square matrix
       if rows and columns are not equal then it is called 
        rectangle matrix/jagged matrix/jagged array

deepToString():
----------------
    - it is used to convert multidimensional array to string
    syntax:
        Arrays.deepToString(arrName);



=============================================================================
=============================================================================

=============================================================================
Strings:
-------
     - it is a collection of characters which is enclosed in 
       double quotes
     - it is a non primitive data type/reference data type
     - it is immutable(can't be modified but it will create a
        new memory space for each changes)
     - String is a class from java.lang package
     - it is indexed and indexed start from 0
Note :
    String s="Toy";
    String rev="";
    for(char c: s.toCharArray()){
        rev=c+rev;
    }
    System.out.println(rev);
if we try to modify string then it will create a new memory space
     Toy ---> 0X1
        ----> 0X2
      T-----> 0X3
      oT-----> 0X4
      yoT-----> 0X5

 

creation of string:
-------------------
    String name="value"; // with string literal
    String name=new String("value"); // with string object

Note : String literal is stored in constant pool area/string area/string pool area
       String object is stored in heap area


String methods:
===============
    
charAt():
--------
      - it is used to access elements of string
      syntax: 
          String name="Java";
          char c=name.charAt(index);
equals():
-------
     - it is used to compare two strings values exactly
     syntax:
         String s1="Java";
         String s2="Java";
         boolean result=s1.equals(s2);
     - it returns true if both strings are equal
     - it returns false if both strings are not equal
equalsIgnoreCase():
------------------
         - it is used to compare two strings values case insensitive
         syntax:
             String s1="Java";
             String s2="java";
             boolean result=s1.equalsIgnoreCase(s2);
         - it returns true if both strings are equal
         - it returns false if both strings are not equal
toCharArray():
-------------
      - it is used to convert string to character array
      syntax:
          String s="Java";
          char []c=s.toCharArray();
      - it returns character array
length():
--------
      - it is used to find length of string
      syntax:
          String s="Java";
          int length=s.length();
      - it returns length of string
indexOf():
----------
      - it is used to find index of first occurrence of character
      syntax:
          String s="Java";
          int index=s.indexOf(c);
      - it returns index of first occurrence of character
      - if character not found it returns -1
lastIndexOf():
--------------
      - it is used to find index of last occurrence of character
      syntax:
          String s="Java";
          int index=s.lastIndexOf(c);
      - it returns index of last occurrence of character
      - if character not found it returns -1
contains():
-----------
      - it is used to check if string contains specified character
      syntax:
          String s="Java";
          boolean result=s.contains(c);
      - it returns true if string contains specified character
      - it returns false if string doesn't contain specified character

toLowerCase():
--------------
      - it is used to convert string to lowercase
toUpperCase():
--------------
      - it is used to convert string to uppercase

split():
-------
      - it is used to split string into multiple strings
      syntax:
          String s="this is java";
          String []name=s.split(" ");
      - it returns string array

replace(old string,new string):
----------
      - it is used to replace one string with another string
      syntax:
          String s="this is java";
          String s1=s.replace("java","python");
      - it returns new string
replace(old char, new char):
---------
      - it is used to replace one character with another character
      syntax:
          String s="java";
          String s1=s.replace('a','e');
      - it returns new string
replaceAll(old string,new string):
----------
      - it is used to replace all occurrences of one string with another string
      syntax:
          String s="this is java java";
          String s1=s.replaceAll("java","python");
      - it returns new string

hashCode():
-----------
     - it is used to get hash code of string
     syntax:
         String s="java";
         int hashCode=s.hashCode();
     - it returns hash code(integer) of string

isEmpty():
-----------
     - it is used to check if string is empty
     syntax:
         String s="java";
         boolean result=s.isEmpty();
     - it returns true if string is empty
     - it returns false if string is not empty
isBlank():
-----------
     - it is used to check if string is blank
     syntax:
         String s="java";
         boolean result=s.isBlank();
     - it returns true if string is blank
     - it returns false if string is not blank

limitations of string:
-----------------------
   - string is immutable , so for every changes in string 
     a new string is created
   - to avoid this we use string buffer and string builder 


StringBuffer:
============
    - it is used to create mutable string
    - it is a class from java.lang package from 1.0 version
    - it is thread safe
    - it is  synchronized
    - performance is low
StringBuilder:
=============
    - it is used to create mutable string
    - it is a class from java.lang package from 1.5 version
    - it is not a thread safe(deals with multiple threads)
    - it is not a synchronized
    - performance is high


methods of string buffer and string builder:
---------------------------------------------

append():
-------
      - it is used to append string
      syntax:
          StringBuffer sb=new StringBuffer("Java");
          sb.append("Python");
      - it returns string buffer
insert():
-------
      - it is used to insert string in specified index position
      syntax:
          StringBuffer sb=new StringBuffer("Java");
          sb.insert(2,"Python");
      - it returns string buffer

delete():
-------
      - it is used to delete string in specified index position
      syntax:
          StringBuffer sb=new StringBuffer("Java");
          sb.delete(2,5(exclusive));
      - it returns string buffer

deleteCharAt():
--------------
      - it is used to delete character in specified index position
      syntax:
          StringBuffer sb=new StringBuffer("Java");
          sb.deleteCharAt(2);
      - it returns string buffer

reverse():
----------
      - it is used to reverse string
          StringBuffer sb=new StringBuffer("Java");
          sb.reverse();
      - it returns string buffer

setCharAt():
-------------
      - it is used to set character in specified index position
      syntax:
          StringBuffer sb=new StringBuffer("Java");
          sb.setCharAt(2,'P');
      - it returns string buffer
setLength():
-------------
      - it is used to set length of string
      syntax:
          StringBuffer sb=new StringBuffer("Java");
          sb.setLength(2);
      - it returns string buffer

String tokenizer:
=================
    - it is used to tokenize string
    - it is a class from java.util package
    - it is used to split string into multiple strings
    syntax:
        String s="this is java";
        StringTokenizer st=new StringTokenizer(s," ");
        while(st.hasMoreTokens()){
            System.out.println(st.nextToken());
        }

hasMoreTokens():
----------------
      - it is used to check if there are more tokens in string
      - returns true if there are more tokens
      - returns false if there are no more tokens

nextToken():
-------------
      - it is used to get next token
      - returns next token(String)
      - returns null if there are no more tokens

nextElement():
---------
    - it is used to get next element
    - returns next element(Object)
    - returns null if there are no more elements



OOPS:(object oriented programming system)
+++++
      1.encapsulation
      2.inheritance
      3.polymorphism
      4.abstraction

1.Encapsulation:
================
     - the process of wrapping/binding data members and methods
       together as a single unit(class) is called encapsulation
  use:
  ----
      - data hiding/data security/data privacy
      - we can hide data by making data members as private
       and providing public methods to access data members
  public methods: 
           1.getter methods: for read/access
           2.setter methods: for write/modify

--------------------------------------------------------------------
getter                                    setter
---------------------------------------------------------------------
used to read/access                    used to write/modify/initialize

return type must be same               return type should be void
as data type of variable

arguments are optional                 arguments are mandatory
--------------------------------------------------------------------

RelationShip:
=============
    - it is a relationship/bond/connection between classes
    types:
       1.inheritance/is - a relationship
       2.has - a relationship


Inheritance:(is - a relationship)
-----------
    -the process of inheriting(acquiring) properties and methods
     from parent to child class is called inheritance
    - to achieve inheritance we use extends and implements keyword

extends: class to class and interface to interface
implements: interface to class 
           +-------------------------------------+
           | parent class/super class/base class |
           | child class/sub class/derived class |
           +-------------------------------------+

Types:
------
    1.single level inheritance
            - inheriting properties and methods from one parent class
              to one child class
    2.multi level inheritance
            - inheriting properties and methods from one parent class
              to child class and to grand child class(as levels)
    3.hierarchical inheritance
            - inheriting properties and methods from one parent class
              to multiple child classes
    4.multiple inheritance
            - inheriting properties and methods from multiple parent
              classes to one child class
    5.hybrid inheritance
            - it is a combination of all other types of inheritance
Note:multiple and hybrid inheritance is not supported in java
      by using classes, it causes ambiguity or diamond problem

ambiguity problem (diamond problem):
------------------------------------
      - it occurs when multiple parent classes have same method name
        and same arguments and return type
      - it occurs when child class constructor calls multiple parent class
        constructor

Note: In java every class is a child of object class(java.lang.Object)
    : by default compiler will add extends object class in every class



Has-a-relationship:(Association)
------------------
      -One class has a relationship with another class
      -One class is a part of another class
ex: Car has a Engine

class Car{                     class Engine{
 
 Engine e;

}                              }

 - Car has an engine (car is a container of engine)
        Types:
        -----
            1.composition
            2.aggregation

1.Composition:
-------------
        -one class is strongly connected with another class
        ex: Car has an Engine
syntax:
class Car{                     class Engine{
 Engine e=new Engine();
}                              }

2.aggregation:
-------------
       - one class is weakly connected with another class
        ex: bus has a passengers
syntax:
class Bus{                     Passenger{

    Passengers p;    
}                              }

==========================================================================================
polymorphism:(many forms)
+++++++++++++
      - the process of having many forms of an object is
        called polymorphism
      - the process of performing same task in different ways
        is called polymorphism
     Types:
     -----
         1.Compile time polymorphism(compile time binding)
             - the process of binding method signature with method body 
               during compile time is called compile time polymorphism
            ex: overloading (constructor overloading and method overloading)

            
         2.Run time polymorphism(run time binding)
              - the process of binding method signature with method body
                during run time is called run time polymorphism
            ex: overriding (method overriding)
     


    method overriding:
    -----------------
       - the process of changing the implementation of parental method
         inside the child class is called method overriding
       - it is a type of runtime polymorphism
    Note : 1.relationship should be parent and child
           2.method return type and method signature must be same as parent
           3.access modifiers should be same  or greater
            than parent visibility

   method overloading:
   ------------------
       - the process of having multiple methods with same name but
         different parameters is called method overloading
       - it is a type of compile time polymorphism
   Note: number, type and order of parameters should be different

------------------------------------------------------------------------------
method overloading                      method overriding
------------------------------------------------------------------------------  
compile time polymorphism              run time polymorphism

inheritance is not required            inheritance is mandatory

method return type can be               method return type should 
different                                        be same as parent

access modifier can be                 access modifier should be 
different                               same or greater than parent

------------------------------------------------------------------------

Note : Method overriding is not possible with static methods , 
       final methods and private  methods
    : If we try to override static method it behaves like method Shadowing


Method Shadowing:
-----------------
     - Static Methods belongs to class and not to objects
     - If we try to override , instead of giving child implementation 
       it gives parent implementation, it is called method shadowing/method hiding


------------------------------------------------------------------------------------------------

Object class:
++++++++++++
         - Object class is the supermost class for every class in java
         - present in java.lang package
         - compiler will add extends object class in every class
         - it consist of 11 methods

getClass()
-----------
       - it returns the class of object
toString()
-----------
       - it returns string representation of object
       - Used to print object values rather than object address
hashCode()
-----------
       - it returns hash code of object
equals()
-----------
       - it returns true if both objects are equal

notify()
notifyAll()
wait()
wait(long timeout)
wait(long timeout,int nanoseconds)
       -- all are thread methods

clone(): used to create deep copy of object
finalize(): used to free memory of object for garbage collection

===============================================================================
constructor chaining:
---------------------
   - the process of calling a constructor from another constructor
     is called constructor chaining
   - can achieve using this and super call statements
   - it helps to reuse code

this: used to refer current object
super: used to refer parent class object

Note : this or super call statement must be the first statement in
       constructor, so both can't used together
===============================================================================

Abstraction:
++++++++++++
    - the process of hiding implementation details and showing
      only functionality of object is called abstraction
    - can achieve using abstract and interface keywords
    - it helps to achieve multiple inheritance

abstract:
--------
    - it is a keyword used for class and method.
    (to create abstract class we use abstract method - incomplete)
    - for abstract method there won't be body, and can declared inside
     abstract class and interface only.
    - abstract class can consist of static and non static
      members and methods , along with it can have abstract methods

note: abstract class can't be instantiated(object can't be created)
      (const is used for re-initialization of object members)
    : abstract can't be final , static and private 



interface:
---------
     - it is a keyword used to create interfaces
     - interface is used to achieve 100% abstraction and multiple inheritance
     - it consist of only static data members(constants)
     - it consist of only abstract methods(non static methods)
     - it dose't have constructor  
     - it can't be instantiated(object can't be created)

Note : static method and default method is introduced in java 8
       which is completed methods and can't be overridden



=======================================================================================================
========================================================================================================


Exception:(problematic situations/statements)
----------
    -The process of handling problematic situations is
     called exception handling
    -can handle using try , catch , finally and throws  keywords

    Exceptions are two types:
    ---------------------------
         1.checked exceptions
         2.unchecked exceptions
checked exceptions:
-------------------
    - checked exceptions are checked at compile time(compiler aware)
     ex: IOException,FileNotFoundException , SQL exception etc.,
    - it is a subclass of Exception class

unchecked exceptions:
---------------------
    - unchecked exceptions are checked at run time(compiler unaware)
     ex: NullPointerException , ArrayIndexOutOfBoundsException etc.,
    - it is a subclass of RuntimeException class

try:
----
    - it is a keyword used for exception handling
    - it is a block of code which is executed when exception is thrown
    - it is used to handle exceptions
    - problematic statements are written inside try block
catch:
-----
    - it is a keyword used for exception handling
    - it is a block of code which is executed when exception is caught
finally:
-------
    - it is a keyword used for exception handling
    - it is a block of code which is executed when exception is thrown
      or not thrown
    - it is used to free resources before exiting from try block

Exception hierarchy:
-------------------
                     Object
                        ^
                        |
                    Throwable
                        ^
                        |
            ___________________________
            ^                          ^
            |                          |
         Exception                    Error
            ^                          
            |                          
_____________________________________________________________
^                          ^             ^             ^
|                          |             |             |
RuntimeException        IOException    SQL exception   FileNotFoundException
        ^
        |_ArithmeticException
        |_NumberFormatException
        |_InputMismatchException
        |_IndexOutOfBoundsException  
        |_ClassCastException  etc.,          

try{

}catch(Exception e){

}

try{

}finally{

}

try{

}catch(Exception e){
    
}finally{

}


try{

}catch(ArithmeticException e){
    
}catch(Exception e){
      
}
Note : when we are having multiple catch blocks , 
     then starting catch block will be executed first
     so have child class exception before parent class exception


try{

}catch(ArithmeticException | ClassCastException e){

}


throws:
-------
    - it is a keyword used for exception handling
    - it is used to throw exceptions
    - it is used to declare exceptions in method signature and
       constructor signature
    - it helps to achieve exception propagation
   Exception propagation:
   ---------------------
       the process of propagating / passing exception from one method
       to another method (caller)is called exception propagation




custom exception:
-----------------
    - it is a user defined exception
    - creating a child class of Exception class
    syntax: 
            class CustomException extends Exception{}
Note : for checked custom exception , inherit Exception class
       for unchecked custom exception , inherit RuntimeException

throw:
------
    - it is a keyword used for exception handling
    - it is used to throw exceptions inside blocks

-------------------------------------------------------------------
throw                                                  throws
--------------------------------------------------------------------
used to throw exception           used to (partial) handle exception
                                  boz, it will propagate exception

inside block                     along with method signature or
                                 constructor signature
           

 
  =============================================================================================================
 
 final: final variables can't be reassigned,
        final methods can't be overridden
        final class can't be inherited
 finally: it is a block used to close the resources in exception handling
 finalize(): it is a method in Object class
             used to free memory of object for garbage collection

        
----------------------------------------------------------------------------------------------------------
Wrapper classes:
----------------
   - it is a class from java.lang package
   - it is a collection of primitive data types
 Types:
     - it is used to convert primitive data types to non primitive data types
     Byte a=10; 
     Short s=10;
     Integer i=10;
     Long l=10l;
     Double d=10d;
     Float f=10f;
     Character c='a';
     Boolean b=true;

The process of converting primitive data types to non primitive data types
is called autoBoxing/boxing/wrapping
 syntax :   int a=10;
            Integer i=a;
The process of converting non primitive data types to primitive data types
is called unboxing
 syntax :   Integer i=10;
            int a=i;  => int a=i.intValue();
            
            Byte b=10;
            byte b1=b.byteValue();


Parsing:
-------
   - it is a process of converting string to primitive data types
   syntax:
       int a=Integer.parseInt("10");

  

  ===========================================================================================================

Thread:(task)
-------
   -it is a light weight process
   -it is a smallest unit of execution
   -it is a collection of instructions
   -it is a collection of stack frames

                    MultiTasking
                        |
                        |
          ---------------------------------------
          |                                      |
    process based multitasking   thread based multitasking

process based multitasking:
--------------------------
        - executing several tasks at the same time simultaneously 
          where each task is independent of other task
  
  ex: In hotel ---multiple chefs --
             chef---1task
             chef---1task

thread based multitasking:
-------------------------
             - executing several/multiple tasks at the same time simultaneously 
               where each task is dependent on other task
  ex: In hotel ---multiple chefs --
         1chef---cutting vegetables
              ----cooking
              ----serving

Note: multiple threads belongs to a single process, but a process is 
      not just a collection of threads


How to create a thread?
----------------------
            1.Thread class
            2.Runnable interface

1.Thread class:
++++++++++++++++ 
         by extending Thread class we can create a thread(user defined thread)
         syntax:
         class MyThread extends Thread{
           
         }

2.Runnable interface:
+++++++++++++++++++
         by implementing Runnable interface we can create a thread(user defined thread)
         syntax:
         class MyThread implements Runnable{
           public void run(){
             //code
           }
         }


Thread Life Cycle:
------------------
            1.New state -> thread is created(user defined thread) - heap area
               syntax: Thread t=new Thread();
            2.Runnable state --> thread is ready to execute , but waiting  for
                                 CPU to execute
               syntax: t.start();
            3.Running state--> thread is executing/Running
               syntax:  t.run();
              Note : run() method is called by start() method automatically

            4.waited/blocked state --> thread is in waiting phase/paused/ blocked state
                                       for another thread to be complete
                  syntax: t.wait();
            5.Timed Waiting state -->thread is waiting for specified time to complete
                  syntax: t.sleep();
            6.Terminated state--> thread is completed or terminated
                  syntax: t.stop();


Note : 1.by using notify() or notifyAll() method we can notify a waiting thread
       we can move thread from waiting state to running state

       2.start() will create a new thread and it is responsible for the execution of run()
-----------------------------------------------------------------------------

synchronized:
++++++++++++++
       - it is a keyword , and non access modifier
       - it is used to make a block synchronized
       -synchronized blocks will ensure that only one thread can access at a time

  -------------------------------------------------------------------------------
                  with synchronized                            without synchronized
  --------------------------------------------------------------------------------
 safe         safe - proper thread handling          unsafe - no proper thread handling

 performance       slower                            faster

 output           always accurate                    may not be accurate
 -------------------------------------------------------------------------------------


Thread Scheduler:
-----------------
   - if multiple threads are waiting to execute, which thread will execute
     1st is decided by Thread Scheduler , which is a part of jvm
    -which algorithm or behavior is used by jvm to decide ,  which can't  be expected 

    - we can provide priority to threads by using setPriority() method

Thread Priority:
----------------
     Thread.MIN_PRIORITY-1
     Thread.NORM_PRIORITY-5
     Thread.MAX_PRIORITY-10

 Note:Thread.NORM_PRIORITY is default priority




Q.what will happen when we have overloading methods for run()?
A.start() method will only check for no args run() method, so it will call 
  no args run() method

Q.What will happen if we are not overriding run() method?
A.start() method will invoke parental run() method , so it wont print anything



Getter and Setter in Thread class:
----------------------------------
  getter : are used to get the info about a thread
           like getName() , getState() etc

  setter : are used to set the info about a thread
           like setName() , setState() etc

constructor of Thread class:
---------------------------
      - Thread class consist overloading constructor used to create
       a thread in different ways
// default constructor
     Thread t1=new Thread(); 
		 System.out.println(t1);
		 
		 Runnable r1=new Thread(); //upCasting
		 System.out.println(r1);
// parameterized constructor used to create a thread with name	 
		 Thread t2=new Thread("ThreadA"); 
		 System.out.println(t2);
// arg const	used to create a thread with target object (thread/runnable) 
		 Thread t3=new Thread(r1);
		 System.out.println(t3);
// arg const used to create a thread with target object (thread/runnable) and name		 
		 Thread t4=new Thread(r1,"Thread B");
		 System.out.println(t4);
// arg const used to create a thread with a  concise task(lambda expression) 
		 Thread t5=new Thread(()->{
			System.out.println("creating with lambda expression"); 
		 });
		 System.out.println(t5);


methods to control execution of a thread:
---------------------------------------
1.start() : used to start a new thread  (NEW---->RUNNABLE)
          : it calls run() method automatically (RUNNABLE---->RUNNING)

2.run() : used to execute a thread (RUNNABLE---->RUNNING)
        :it won't create a new thread

3.sleep(long milliseconds) : used to pause a thread for specified time
                            (RUNNING---->TIMED WAITING/BLOCKED)

4.sleep(long milliseconds,int nanoseconds) : used to pause a thread for specified time
                                             (RUNNING---->TIMED WAITING/BLOCKED)

5.join() : used to wait for a thread to complete/finish

6.join(long milliseconds) : used to wait for a thread to complete for specified time

7.yield() : used to give a chance to other threads to execute

8.interrupt() : used to interrupt a thread

9.isInterrupted() : used to check whether a thread is interrupted or not
                  : it returns true if thread is interrupted otherwise false

10.stop() : used to terminate a thread forcefully (unsafe operation)
            (RUNNING---->TERMINATED)

11.wait(): used to wait for a thread to complete (RUNNING---->TIMED WAITING/BLOCKED)

12.notify(): used to notify a waiting thread (TIMED WAITING/BLOCKED---->RUNNING)

13.notifyAll(): used to notify all waiting threads (TIMED WAITING/BLOCKED---->RUNNING)

-----------------------------------------------------------------------------------------------------------------------
Dead Lock:
++++++++++
    -when two threads are waiting for each other to complete their execution
                          or
    -when two or more  threads are waiting for each other to release a lock
    it is called deadlock
    -it can be handled by using synchronized blocks

 Ex: two persons are walking in a narrow road and they want to cross the road
     by blocking each other-----both will wait forever


DeadLock happens when:
              1.two or more  threads hold resources(locks)
              2.Each thread waits for other thread to complete or release task

can overcome :
           1.use a consistent locking order(recommended)
           2.use tryLock() from ReentrantLock
           3.avoid nested locks

----------------------------------------------------------------------------------
Daemon Thread:
++++++++++++++
    - the daemon thread is a thread that is automatically started 
      by the JVM
    - a daemon thread is a background service thread that runs continuously
      and performs a task in the background
    - we can make a thread as a daemon thread by using setDaemon(true) method
    - mainly used for garbage collection , file monitoring ,background logging etc

    -setDaemon() - used to make a thread as a daemon thread
                 - default value is false , so it is not a daemon thread 
    -a daemon thread is mainly used to perform background tasks that should not prevent 
      the  jvm exiting , when the application is in running.

    -isDaemon() - used to check whether a thread is a daemon thread or not
ex:
   main thread(non daemon thread) --Main worker /manager
   daemon thread --assistant workers

-----------------------------------------------------------------------------------------
Thread Group:
+++++++++++++
          -it is a way to group threads together/ collection of threads
          -so that we can control them together as a single unit
        ex: checking priority, joining threads, interrupting threads etc
          -it can achieve by using ThreadGroup class present in java.lang package
  
  methods in ThreadGroup
  ---------------------
      list()-- used to get the list of threads in the group
      activeCount()-- used to get the number of active threads in the group
      activeGroupCount()-- used to get the number of active groups in the group
      interrupt()-- used to interrupt all the threads in the group
      destroy()-- used to destroy all the threads in the group
      getName()-- used to get the name of the group
      setName()-- used to set the name of the group
---------------------------------------------------------------------------------------------------------

+-----------------------------------------------------------------------------------------------------+
| Feature     | Synchronized Method                     | Synchronized Block                          |
| ----------- | --------------------------------------- | ------------------------------------------- |
| Scope       | Entire method                           | Only part of the method                     |
| Performance | Slower                                  | Faster                                      |
| Flexibility | Low                                     | High                                        |
| Lock Type   | Always current object (`this`) or class | Can choose any lock object                  |
| Use Case    | When whole method must be thread-safe   | When only critical section needs protection |
======================================================================================================================================
======================================================================================================================================

  drawback of arrays:
-----------------
  - arrays are collection of data /value/objects
  - arrays are fixed in size(risk in over/under size allocation)
  - arrays are not thread safe
  - arrays are not synchronized
  - arrays will accept same data type values only
  - manipulations of arrays are slow(there are no inbuilt methods )
  - arrays are low level and not user friendly
    (sorting , searching , insertion , deletion , element shifting etc)
  


Collection Framework:
+++++++++++++++++++++
   - it is a framework that provides collection of objects
   - it works only for non -primitive data type/ objects
   - A group/multiple  of individual data/objects is called collection
   - it is introduced in java 1.2 version 
   - In collection framework , mainly we have two(root) types of interfaces
        1. Collection interface
        2. Map interface

Framework: 
---------
  -a framework is a collection/set of classes and interfaces that provides
  a ready made solution for a particular problem


1.collection interface:  
-----------------------
      - It is a interface present in java.util package since java 1.2
      - It is a child interface of Iterable interface
      - it consist three child interfaces
              1.List -ArrayList, LinkedList, Vector
              2.Set - HashSet, LinkedHashSet, TreeSet
              3.Queue - ArrayDeque, LinkedBlockingQueue, PriorityQueue

methods of collection interface:
--------------------------------
size()  :used to get the size of collection
        :returns int , size of collection
        :if collection is empty returns [] /0 

add(element)  :used to add an element to collection
              :returns boolean , if element is added returns true,
              if element is not added returns false

addAll(collection):used to add multiple elements to collection
                  :returns boolean , if elements are added returns true,
                  if elements are not added returns false
remove(element):used to remove an element from collection
                :returns boolean , if element is removed returns true,
                if element is not removed returns false
removeAll(collection):used to remove multiple elements from collection
                     :returns boolean , if elements are removed returns true,
                     if elements are not removed returns false

removeIf(predicate):used to remove elements from collection
                   :returns boolean , if elements are removed returns true,
                   if elements are not removed returns false

retainAll(collection):used to retain elements from collection
                     :returns boolean , if elements are retained returns true,
                     if elements are not retained returns false

contains(element):used to check if an element is present in collection
                   :returns boolean , if element is present returns true,
                   if element is not present returns false
containsAll(collection):used to check if all the elements are present in collection
                       :returns boolean , if all the elements are present returns true,
                       if all the elements are not present returns false

isEmpty():used to check if collection is empty
          :returns boolean , if collection is empty returns true,
          if collection is not empty returns false

clear():used to clear all the elements from collection
         :returns boolean , if collection is cleared returns true,
         if collection is not cleared returns false

toArray() :used to convert collection to array
          :returns Object[] , array of objects
          :if collection is empty returns []

iterator(): used to get the iterator of collection
            :returns Iterator , iterator of collection
            :if collection is empty returns null

spiltIterator():used to get the split iterator of collection
                :returns SpiltIterator , split iterator of collection
                :if collection is empty returns null

forEach():used to iterate over collection
          :returns void , it will iterate over collection
          :if collection is empty returns null

stream():used to get the stream of collection
          :returns Stream , stream of collection
          :if collection is empty returns null

parallelStream():used to get the parallel stream of collection
          :returns Stream , parallel stream of collection
          :if collection is empty returns null

equals():used to check if two collections are equal
          :returns boolean , if two collections are equal returns true,
          if two collections are not equal returns false

hashCode():used to get the hash code of collection
            :returns int , hash code of collection
            :if collection is empty returns 0

toString():used to get the string representation of collection
            :returns String , string representation of collection
            :if collection is empty returns ""

---------------------------------------------------------------------
removeAll()                             retainAll()
------------------------------------------------------------
removes all the elements from         removes all the elements 
collection (matching elements)        except the elements (matching elements)





List interface:
---------------
       -it is a child of collection interface , present in java.util package since java 1.2
       -it is a collection of ordered elements(index based)
       -it allows duplicates

    

add(index,e): used to add an element at a particular index position
            :if index is out of range then it will throw IndexOutOfBoundsException

addAll(index,collection):used to add multiple elements at a particular index position
                        :if index is out of range then it will throw IndexOutOfBoundsException

addFirst(e):used to add an element at the beginning of the list

addLast(e):used to add an element at the end of the list

get(index): used to get the element at a particular index position
          :returns E , element at a particular index position
          :if index is out of range then it will throw IndexOutOfBoundsException

getFirst():used to get the first element of the list

getLast():used to get the last element of the list

indexOf(e):used to get the index of an element
          :returns int , index of element
          :if element is not present returns -1

lastIndexOf(e):used to get the last index of an element
          :returns int , last index of element
          :if element is not present returns -1

listIterator():used to get the list iterator of the list
              :returns ListIterator , list iterator of the list
              :if list is empty returns null

listIterator(index):used to get the list iterator of the list at a particular index position
                    :returns ListIterator , list iterator of the list at a particular index position
                    :if index is out of range then it will throw IndexOutOfBoundsException

remove(index):used to remove an element at a particular index position
             :returns E , element at a particular index position
             :if index is out of range then it will throw IndexOutOfBoundsException

removeFirst():used to remove the first element of the list

removeLast():used to remove the last element of the list

replaceAll(collection):used to replace all the elements of the list

retainAll(collection):used to retain all the elements of the list
                     :returns boolean , if elements are retained returns true,
                     if elements are not retained returns false

reversed():used to reverse the list
          :returns reversed List
         
set(index,e):used to set/update/replace the element at a particular index position 
            :returns E , element at a particular index position
            :if index is out of range then it will throw IndexOutOfBoundsException

sort(comparator):used to sort the list

subList(startIndex,endIndex):used to get the sub list of the list
                            :returns List , sub list of the list
                            :if startIndex is greater than endIndex then it will throw IndexOutOfBoundsException


Set interface:
--------------
   -Set is a child interface of Collection interface present in java.util package since java 1.2
   -Set is a collection of unique elements(won't allow duplicates)
   -Set is a collection of unordered elements
   -No extra methods beyond what is inherited from Collection.

------------------------------------------------------------------------------------
                    HashSet              LinkedHashSet             TreeSet
-----------------------------------------------------------------------------------
order                no                  insertion order         sorting order

null values          yes                   yes                       no(NPE)

duplicates           no                    no                        no

indexed access       no                    no                        no

performance          faster               slower                    slower

thread-safe          no                    no                        no
------------------------------------------------------------------------------------



Feature                   	List                         	Set
------------------------------------------------------------------------------------
Order	          Maintains insertion order	    May or may not (depends on implementation)
Duplicates  	  Allowed	                      Not allowed
Indexed Access	  Yes                        	  No
Implementations	 ArrayList, LinkedList	        HashSet, LinkedHashSet, TreeSet
-----------------------------------------------------------------------------------


Queue interface:
---------------
     - Queue is a child interface of Collection interface present in java.util package since java 1.2
     - Queue is a collection of ordered elements(first in first out - FIFO)

offer(e):used to add an element to the queue
         :returns boolean , if element is added returns true,
         if element is not added returns false

poll():used to remove an element from the queue
       :returns E , element from the queue
       :if queue is empty returns null

peek():used to get the first element of the queue
      :returns E , first element of the queue
      :if queue is empty returns null

element():used to get the first element of the queue
          :returns E , first element of the queue
          :if queue is empty returns NoSuchElementException

remove():used to remove an element from the queue
         :returns E , element from the queue
         :if queue is empty returns NoSuchElementException


-------------------------------------------------------------------------------
                    PriorityQueue            LinkedList                   ArrayDeque
--------------------------------------------------------------------------------
parent interface         Queue              List,Deque,Queue             Deque,Queue

random access             no                   yes (index)                  no

ordering           priority order           insertion order            insertion order
                                              (fifo)              

null values               no                   yes                         no

useCase            priority matters         both list and queue        both stack and queue
-----------------------------------------------------------------------------------------





Feature                 	List              	Set                	Queue
------------------------------------------------------------------------------------------
Duplicates Allowed	       Yes                 No                  Yes
Maintains Order	           Yes (index)	     Depends               Yes (FIFO)
Indexed Access	           Yes	               No	                  No
Special Methods	       get, set etc.	      None extra	  offer, poll, peek etc.
Main Usage	           Random access	    Unique elements	    FIFO processing


ArrayList: 
---------
   -ArrayList is a implementation class that implements the List interface.
   -ArrayList is a dynamic array that can grow and shrink as needed.
   -ArrayList is not thread-safe.
   -ArrayList is slower than LinkedList.
   -mainly used for read-write operations
   -initial capacity is 10
methods of ArrayList:
---------------------
ensureCapacity(int minCapacity):used to ensure that the capacity of the ArrayList is at least minCapacity
                               :if minCapacity is less than current capacity then it will not change the capacity
                               :if minCapacity is greater than current capacity then it will change the capacity
                               :returns boolean , if capacity is changed returns true,
                               if capacity is not changed returns false

capacity():used to get the capacity of the ArrayList
          :returns int , capacity of the ArrayList

trimToSize():used to trim the size of the ArrayList to the current size
            :returns void , it will trim the size of the ArrayList to the current size

clone():used to clone the ArrayList
       :returns Object , clone of the ArrayList

LinkedList:
-----------
   -LinkedList is a implementation class that implements the List interface.
   -LinkedList is a doubly linked list that can grow and shrink as needed.
   -LinkedList is thread-safe.
   -LinkedList is faster than ArrayList.
   -mainly used for read-write operations
   -initial capacity is 0(there is no concept of initial capacity in LinkedList, it consist nodes)

methods of LinkedList:
---------------------
removeFirst()	:	Removes first element
removeLast()	:	Removes last element
offerFirst(E e)	:	Offers to the front
offerLast(E e)	:	Offers to the end
pollFirst()	:	Retrieves and removes first
pollLast()	:	Retrieves and removes last
peekFirst()	:	Peeks first element
peekLast()	:	Peeks last element
push(E e)	:	Pushes onto stack (head)
pop()	:	Pops from stack (head)
descendingIterator()	:	Returns reverse iterator

---------------------------------------------------------------------------------------------
Feature                     	ArrayList                              	LinkedList
-------------------------------------------------------------------------------------------
default capacity                10                              doesn't have
Structure	                   Dynamic Array                     	Doubly Linked List
thread safe                  not thread safe                    not thread safe
Access Speed             	    Fast (O(1))	                      Slow (O(n))
Insert/Delete at Start	      Slow (O(n))                       Fast (O(1))
Insert/Delete in Middle	      Slow (O(n))	                      Moderate (O(n))
Memory Efficiency	         Better (less overhead)	             Higher (node pointers)
                                                             Extra memory for pointers (next & prev) in each node
Use Case	                Best for read-heavy apps	           Best for write-heavy apps
-------------------------------------------------------------------------------------



Vector:
-------
   -Vector is a legacy class that also implements the List interface.
   -It is similar to ArrayList, but with one major difference:
   -Vector is synchronized (i.e., thread-safe).
   -Vector is slower than ArrayList. 
   -Vector is deprecated and is replaced by ArrayList.
   -mainly used for Multi-threaded list (without external sync)


 Iterator
----------
    -Used to traverse elements in forward direction only.
    -Works on any Collection (e.g., List, Set, Queue).
    -Allows safe removal of elements during iteration.
Method	
-------
hasNext()	:Returns true if there are more elements
          :Returns false if there are no more elements 
next()	:Returns the next element
        :Throws NoSuchElementException if there are no more elements
remove()	:Removes the current element (optional)
          :Throws UnsupportedOperationException if remove() is not supported

 ListIterator
 ------------
    -Used only with List implementations.
    -Can traverse in both forward and backward directions.
    -Can add, update, and remove elements during traversal.

Method
-------
hasPrevious():	Checks for element in reverse
             :Returns true if there are more elements
             :Returns false if there are no more elements
previous()	:Gets the previous element
            :Throws NoSuchElementException if there are no more elements
nextIndex()	:Returns the index of the next element
            :Throws UnsupportedOperationException if nextIndex() is not supported
previousIndex()	:Returns the index of the previous element
                :Throws UnsupportedOperationException if previousIndex() is not supported
add(E e)	:Adds an element
set(E e)  :Updates the last returned element


SpiltIterator
-------------
    -Used only with List implementations.
    -Can traverse in both forward and backward directions.
    -Can add, update, and remove elements during traversal.
    -Can split into multiple iterators.
    -added in java 8

methods:
-------
trySplit():	tries to split the iterator into multiple iterators
            :returns Spliterator<T> if successful, else returns null  
tryAdvance():	tries to advance the iterator
              :returns true if successful, else returns false
forEachRemaining():	performs an action for each remaining element


Map:
------
   -Map is a  interface present in java.util package since java 1.2
   -Map is a collection of key-value pairs
   -Map is a collection of unique keys
   -Map is a collection of ordered elements(key based)
   -Map allows duplicates(values)
   -Map allows null keys
   -Map allows null values

methods:
-------
put(K key, V value)  Adds/updates a key-value pair.
get(Object key)  Returns the value for the given key.
remove(Object key)  Removes the entry for the key.
containsKey(Object key)  Checks if key exists.
containsValue(Object value)  Checks if value exists.
size()  Returns number of entries.
isEmpty()  Checks if map is empty.
clear()  Removes all entries.
keySet()  Returns a Set of keys.
values()  Returns a Collection of values.
entrySet()  Returns a Set of key-value pairs.
putIfAbsent(K key, V value)  Puts value only if key is not already mapped.
replace(K key, V value)  Replaces value for key if present.
replace(K key, V oldValue, V newValue)  Replaces only if currently mapped to oldValue.
getOrDefault(Object key, V defaultValue)  Returns value if found, otherwise default.
forEach(BiConsumer<? super K, ? super V> action) Iterates through all key-value pairs using a lambda.
compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) Recomputes value for a key. Removes entry if result is null.
computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) Computes and inserts value only if key is not already mapped (or mapped to null).
computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) Updates value only if key is already mapped. Removes if result is null.
merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) Inserts value if absent, otherwise merges old and new value. Removes if function returns null.
------------------------------------------------------------------------------------

                  HashMap          TreeMap          HashTable           LinkedHashMap
-----------------------------------------------------------------------------------
ordering          no order        key based         no order            insertion order

null key          allow           not allow         not allow           allow  

null values      allow             allow           not allow           allow

thread safe       no                no                 yes                 no

performance       fast             slow             slow                slightly slower

internal ds       hashTable      red-black tree      hashTable        doubly linked list
--------------------------------------------------------------------------------------------


+----------------------------------------------------+
| HashMap               | Hashtable                  |
| --------------------- | -------------------------- |
| Not synchronized      | Synchronized (thread safe) |
| Allows null key/value | Does NOT allow null        |
| Faster                | Slower                     |
| Modern                | Legacy(older)              |
+----------------------------------------------------+


-----------------------------------------------------------------------------------------------------------
Feature                     	Comparable                                    	Comparator
-----------------------------------------------------------------------------------------------------------
Package	                        java.lang	                                     java.util
Method	                        compareTo(T o)	                                compare(T o1, T o2)
Where defined	          Inside the class of the object	               Separate class, lambda expression
Sorting type	            Natural ordering (default)	                 Custom ordering (can have multiple)
Flexibility             	Only one way of sorting                         	Many ways of sorting
Example use          	     Collections.sort(list)                      	Collections.sort(list, comparator)

------------------------------------------------------------------------------------------------------------


